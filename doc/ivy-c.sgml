<!doctype linuxdoc system>

<!--
	The Ivy C guide

	Copyright (c) 1999
	Centre d'Etudes de la Navigation Aerienne

	SGML source file

	Authors: Stéphane Chatty <chatty@cena.dgac.fr>

	$Id$

	Please refer to file version.h for the
	copyright notice regarding this software
-->


<article>

<title>The Ivy C library guide
<author>Stéphane Chatty, <tt/chatty@cena.dgac.fr/
<date>12 April 1999
<abstract>
This document is a programmer's guide that describes how to use the Ivy C
library to connect applications to an Ivy bus. This guide describes version 3.0
of the library.
</abstract>

<toc>

<sect>General information
<sect1>What is Ivy?
<p>

Ivy is a software bus designed at CENA (France). A software bus is a system 
that allows software applications to exchange information with the illusion of
broadcasting that information, selection being performed by the receiving
applications. Using a software bus is very similar to dealing with events in a
graphical toolkit: on one side, messages are emitted without caring about who
will handle them, and on the other side, one decide to handle the messages that
have a certain type or follow a certain pattern. Software buses are mainly aimed 
at facilitating the rapid development of new agents, and at managing a dynamic
collection of agents on the bus: agents show up, emit messages and receive some, 
then leave the bus without blocking the others.

<sect2>Architecture and principles
<p>
As opposed to other software buses, Ivy does not depend on a centralised
server. Actually, Ivy is mostly a communication convention between processes,
implemented through a collection of libraries in several languages.

<p>

From the programmer's point of view, Ivy is an information  broadcasting
channel. The main functions are:

<itemize>
<item> connecting to a bus.<em> Example: IvyInit (b, "192.126:2011")</em>
<item> sending a message.<em> Example: IvySend (b, "HELLO %s", world)</em>
<item> bind a message pattern to a callback function.<em> Example: IvyBind (b, "HELLO (.*)", cb)</em>
<item> the main loop.<em> Example : IvyLoop ()</em>
</itemize>

Ivy's
decentralised connection scheme probably incurs limitations in terms of how many
applications can be connected to an Ivy bus, but this simplifies management a
lot. Basically, an Ivy bus is just a set of applications that decide to
communicate together. The only conventions between these applications are:
<enum>
<item> the use of the Ivy protocol (for obvious reasons)
<item> a bus address, made of a broadcast port number (a bit like a citizen band
channel) and a set of networks addresses
</enum>
When an application wants to connect to a bus, it sends a broadcast message on the
networks specified in the bus address, so that all applications present on those 
networks and listening on the specified port number connect to it. It then
becomes part of the bus, and listens like the other ones.
<p>
The messages are exchanged in text format, and bindings are based on regular
expressions with captures. If an application subscribes to 
    <tt/HELLO (.*)/ an if another application emits the message <tt/HELLO WORLD/, a
callback will be called in the first application with <tt/WORLD/ as an argument.


<sect2>Using Ivy
<p>
You can use Ivy through applications that have been provided to you. This is the 
case for <tt/ivyprobe/, an Ivy agent that allows you to examine the messages
exchanged on a given bus and to send messages on that bus. You can refer to the
web site <tt/http:/ for a list of available agents. However, what you will
usually want to do is to develop your own applications. In order to do that you
can use an Ivy connection kit, that is a library that implements Ivy.


<p>
Libraries that implement Ivy are available in the following environments:
<itemize>
<item> in C on Unix and Windows platforms, with it own communication library
<item> in C++ on Windows platforms
<item> in C++ on Unix platforms, integrated with the Uch communication library
<item> in C++ on Unix platforms, integrated with  OpenInventor
<item> in C++ on Macintosh
<item> in Perl and in Perl/Tk
<item> integrated with Object Caml on Unix platforms
<item> in Scheme on Unix platforms
<item> in Java
</itemize>
<p>

Connecting your application to an Ivy bus just consists in choosing the
appropriate library, add the appropriate message emission and reception calls to
your code, use the main loop provided in the library or make the necessary
integrations, and get your code running! 

<sect1>The Ivy C library
<p>
The Ivy C library (aka Ivy-C or ivy-c) is a C library that allows you to connect 
applications to an Ivy bus. You can use it to write applications in C or any
other language that supports C extensions. This guide documents how you can do
that.
<p>
The Ivy C library is known to compile and work in WindowsNT and Linux
environments. It should be easy to use on most Posix environments. 
<p>
The Ivy C library was originally developed by François-Régis Colin at CENA. It
is maintained by the CENA-Toulouse team.

<sect>Getting and installing the Ivy C library
<p>
You can get the latest versions of the Ivy C library from CENA (http://XXX) or
from one of the Fairway sites (for instance http://XXX). Depending whether you
use a supported distribution of Linux or not, you have the following options:

<sect1>Installing RedHat or Debian packages
<p>

<sect1>Getting and compiling the sources
<p>



<sect>Basic functions

<sect1>Initialization and main loop
<p>
Initializing an Ivy agent with the Ivy C library is a two step process. First of 
all, you should initialize the library by calling function <tt/IvyInit/. Once
the library is initialized you can create timers and add subscriptions, but your 
agent is still not connected to any bus. In order to connect, you should call
function <tt/IvyStart/. In theory, initialization is then over. However in
practice, as for any asynchronous communication or interaction library, nothing
happens until your application has reached the main loop.
<p>
The Ivy C library provides its own main loop: <tt/IvyMainLoop/. You should use
it unless you already use a toolkit that provides its own main loop and you want 
to use that one. If it is the case, please refer to section XX. Otherwise, just
call <tt/IvyMainLoop/. From within the main loop, you can call <tt/IvyStop/ to
exit the loop.

Here are more details on those functions:

<tscreen><verb>
void IvyInit (const char* agentname,
			const char* hello_msg,
			IvyApplicationCallback app_cb,
			void *app_data,
			IvyDieCallback die_cb,
			void *die_data);
</verb></tscreen>
initializes the library. blahblah

<tscreen><verb>
void IvyStart (const char* bus);
</verb></tscreen>
connects your application to the bus specified in <tt/bus/. The string provided
should follow the convention described in section XX. Example: <tt/"127:2010"/.

<tscreen><verb>
void IvyMainLoop (void (*hook) (void));
</verb></tscreen>
makes your application enter the main loop in which it will handle asynchronous
communications and signals.

<tscreen><verb>
void IvyStop ();
</verb></tscreen>
makes your application exit the main loop.


<sect1>Emitting messages
<p>
Emitting a message on an Ivy bus is much like printing a message on the standard 
output. However, do not forget that your message will not be emitted if Ivy has
not been properly initialized and if you do not have a main loop of some sort
running. To emit a message, use <tt/IvySendMsg/, which works like <tt/printf/:

<tscreen><verb>
void IvySendMsg (const char* format, ...);
</verb></tscreen>
sends a message on the bus. This function has exactly the same behaviour as
<tt/printf/, <tt/sprintf/ or <tt/fprintf/.


<sect1>Subscribing to messages
<p>
Subscribing to messages consists in binding a callback function to a message
pattern. Patterns are described by regular expressions with captures. When a
message matching the regular expression is detected on the bus, the callback
function is called. The captures (ie the bits of the message that match the
parts of regular expression delimited by brackets) are passed to the callback
function much like options are passed to <tt/main/. Use function <tt/IvyBindMsg/ 
to bind a callback to a pattern, and function <tt/IvyUnbindMsg/ to delete the
binding.
<tscreen><verb>
MsgRcvPtr IvyBindMsg (MsgCallback cb,
		void* data,
		const char* regex_format, ...);
</verb></tscreen>
binds callback function <tt/cb/ to the regular expression specified by
<tt/regex_format/ and the optional following arguments. <tt/regex_format/ and
the following arguments are handled as in <tt/printf/.

<tscreen><verb>
void IvyUnbindMsg (MsgRcvPtr id);
</verb></tscreen>
deletes the binding specified by <tt/id/

<p>
In what precedes, <tt/MsgRcvPtr/ is an opaque type used to identify bindings,
<tt/data/ is a user pointer passed to the callback whenever it is called, and
<tt/MsgCallback/ is defined as follows:
<tscreen><verb>
typedef void (*MsgCallback)(IvyClientPtr app, void *data, int argc, char **argv);
</verb></tscreen>


<sect1>Example
<p>
The following application connects to an Ivy bus, translates messages <tt/"Hi
[name]"/ to <tt/"Bonjour [name]"/, and quits on message <tt/"Bye"/.
<tscreen><verb>
#include <stdlib.h>
#include <stdio.h>
#include <getopt.h>
#include <ivy.h>
#include <ivyloop.h>

/* callback associated to "Hi" messages */
void HiCallback (IvyClientPtr app, void *data, int argc, char **argv)
{
	if (argc != 1)
		fprintf (stderr, "wrong format!\n");
	else
		IvySendMsg ("Bonjour %s", argv[0]);
}

void ByeCallback (IvyClientPtr app, void *data, int argc, char **argv)
{
	IvyStop ();
}

main (int argc, char**argv)
{
	/* handling of -b option */
	const char* bus = 0;
	char c;
	while (c = getopt (argc, argv, "b:") != EOF) {
		switch (c) {
		case 'b':
			bus = optarg;
			break;
		}
	}

	/* handling of environment variable */
	if (!bus)
		bus = getenv ("IVYBUS");

	/* initializations */
	IvyInit ("MagicTranslater", "Hello le monde", 0, 0, 0, 0);
	IvyStart (bus);

	/* bindings */
	IvyBindMsg (HiCallback, 0, "^Hi (.*)");
	IvyBindMsg (ByeCallback, 0, "^Bye$");

	/* main loop */
	IvyMainLoop (0);
}

</verb></tscreen>




<sect>Advanced functions
<sect1>Utilities
<sect1>Direct messages

<sect>Managing timers and other channels
<p>

In your applications, you may need to manage other input/output channels than an
Ivy bus: a serial driver, the channels defined by a graphical toolkit, or simply 
stdin and stdout. The same applies for timers. You can either manage those
channels or timers from the Ivy main loop, or instead use the main loop provided by
another library.

<sect1>Adding channels and timers to the Ivy main loop
<sect2>Channels
<p>
You can get a channel to be managed from the Ivy main loop by using functions
<tt/IvyChannelSetUp/ and <tt/IvyChannelClose/.
<tscreen><verb>
Channel IvyChannelSetUp (HANDLE fd,
			void* data,
			ChannelHandleDelete handle_delete,
			ChannelHandleRead handle_read);
</verb></tscreen>
ensures that function <tt/handle_read/ is called whenever data is read on file
descriptor <tt/fd/, and function <tt/handle_delete/ whenever <tt/fd/ is
closed, and

<tscreen><verb>
void IvyChannelClose (Channel ch);
</verb></tscreen>
terminates the management of channel <tt/ch/.

<p>
In what precedes, <tt/Channel/ is an opaque type defined by the Ivy C library, <tt/data/ is a pointer that will be passed to functions <tt/handle_read/ 
and <tt/handle_delete/. It can be defined at will by users. 
The types HANDLE, ChannelHandleDelete and
ChannelHandleRead are as follows:
<tscreen>Unix: <verb>typedef int HANDLE;</verb>
Windows: <verb>typedef SOCKET HANDLE;</verb>
<verb>
typedef void (*ChannelHandleDelete)(void *data);
typedef void (*ChannelHandleRead)(Channel ch, HANDLE fd, void* data);
</verb></tscreen>
<p>

<sect2>Timers
<p>
You can get a function to be repeatedly called by using function
<tt/TimerRepeatAfter/:

<tscreen><verb>
TimerId TimerRepeatAfter (int nbticks, long delay, TimerCb handle_timer, void* data);
</verb></tscreen>
ensures that function <tt/handle_timer/ is called <tt/nbticks/ times at
intervals of <tt/delay/ seconds, thus creating a timer.

<tscreen><verb>
void TimerModify (TimerId id, long delay);
</verb></tscreen>
changes the delay used for timer <tt/id/.

<tscreen><verb>
void TimerRemove (TimerId id);
</verb></tscreen>
deletes timer <tt/id/, thus stopping it.

In what precedes, <tt/data/ is passed to <tt/handle_timer/ every time it is
called. <tt/delay/ is expressed in milliseconds.
If <tt/nbticks/ is set to <tt/TIMER_LOOP/, then <tt/handle_timer/ will
be called forever. <tt/TimerCb/ is as follows:
<tscreen><verb>
typedef void (*TimerCb)(TimerId id, void *data, unsigned long delta);
</verb></tscreen>

<p>
<sect1>Adding Ivy to another main loop

<sect2>Functions to be provided
<p>
You can decide to use the main loop from another toolkit such as the X Toolkit
or the Tk toolkit. If you do that, you'll have to define three functions that
Ivy will use to get its own channels managed by the other toolkit. The three
following global variables should be defined:
<tscreen><verb>
ChannelInit channel_init;
ChannelSetUp channel_setup;
ChannelClose channel_close;
</verb></tscreen>

They should point to functions that respectively:
<itemize>
<item> make the necessary global initializations before entering the main loop
<item> initialize a channel and ensure that it is managed by the main loop
<item> close a channel
</itemize>
<p>

The types <tt/ChannelInit/, <tt/ChannelSetUp/ and <tt/ChannelClose/ are defined
as follows:

<tscreen><verb>
typedef void (*ChannelInit)(void);
typedef Channel (*ChannelSetUp)(
        HANDLE fd,
        void *data,
        ChannelHandleDelete handle_delete,
        ChannelHandleRead handle_read);
typedef void (*ChannelClose)( Channel channel );
</verb></tscreen>


<sect2>Type to be defined
<p>
In order to implement the three previous functions, you will need to define the
hidden type <tt/struct _channel/ (the type <tt/Channel/ is defined as <tt/struct 
_channel*/). Use it to store the data provided by the other toolkit.

<sect2>Overriding the Ivy main loop
<p>
In order to override the default definition of the three previous variables, you 
will need:
<itemize>
<item> either to create a new library by replacing file <tt/ivyloop.o/ with the file
that contains your definitions
<item> or ...
</itemize>

<p>




<sect>Conventions for writing applications
<p>
... the environment variable <tt/IVYBUS/ ..., ... the option <tt/-b/ ...

</article> 
